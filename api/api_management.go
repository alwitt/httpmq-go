/*
httpmq

HTTP/2 based message broker built around NATS JetStream

API version: v0.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ManagementApiService ManagementApi service
type ManagementApiService service

type ApiV1AdminAliveGetRequest struct {
	ctx        _context.Context
	ApiService *ManagementApiService
}

func (r ApiV1AdminAliveGetRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminAliveGetExecute(r)
}

/*
V1AdminAliveGet For management REST API liveness check

Will return success to indicate management REST API module is live

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AdminAliveGetRequest
*/
func (a *ManagementApiService) V1AdminAliveGet(ctx _context.Context) ApiV1AdminAliveGetRequest {
	return ApiV1AdminAliveGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminAliveGetExecute(r ApiV1AdminAliveGetRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminAliveGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/alive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminReadyGetRequest struct {
	ctx        _context.Context
	ApiService *ManagementApiService
}

func (r ApiV1AdminReadyGetRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminReadyGetExecute(r)
}

/*
V1AdminReadyGet For management REST API readiness check

Will return success if management REST API module is ready for use

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AdminReadyGetRequest
*/
func (a *ManagementApiService) V1AdminReadyGet(ctx _context.Context) ApiV1AdminReadyGetRequest {
	return ApiV1AdminReadyGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminReadyGetExecute(r ApiV1AdminReadyGetRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminReadyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamGetRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	httpmqRequestID *string
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamGetRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamGetRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamGetRequest) Execute() (ApisAPIRestRespAllJetStreams, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamGetExecute(r)
}

/*
V1AdminStreamGet Query for info on all streams

Query for the details of all streams

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AdminStreamGetRequest
*/
func (a *ManagementApiService) V1AdminStreamGet(ctx _context.Context) ApiV1AdminStreamGetRequest {
	return ApiV1AdminStreamGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ApisAPIRestRespAllJetStreams
func (a *ManagementApiService) V1AdminStreamGetExecute(r ApiV1AdminStreamGetRequest) (ApisAPIRestRespAllJetStreams, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisAPIRestRespAllJetStreams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamPostRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	setting         *ManagementJSStreamParam
	httpmqRequestID *string
}

// JetStream stream setting
func (r ApiV1AdminStreamPostRequest) Setting(setting ManagementJSStreamParam) ApiV1AdminStreamPostRequest {
	r.setting = &setting
	return r
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamPostRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamPostRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamPostRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamPostExecute(r)
}

/*
V1AdminStreamPost Define new stream

Define new JetStream stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AdminStreamPostRequest
*/
func (a *ManagementApiService) V1AdminStreamPost(ctx _context.Context) ApiV1AdminStreamPostRequest {
	return ApiV1AdminStreamPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminStreamPostExecute(r ApiV1AdminStreamPostRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.setting == nil {
		return localVarReturnValue, nil, reportError("setting is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	// body params
	localVarPostBody = r.setting
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	consumerName    string
	httpmqRequestID *string
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameConsumerConsumerNameDeleteExecute(r)
}

/*
V1AdminStreamStreamNameConsumerConsumerNameDelete Delete one consumer of a stream

Delete one consumer of a stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @param consumerName JetStream consumer name
 @return ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerConsumerNameDelete(ctx _context.Context, streamName string, consumerName string) ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest {
	return ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		streamName:   streamName,
		consumerName: consumerName,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerConsumerNameDeleteExecute(r ApiV1AdminStreamStreamNameConsumerConsumerNameDeleteRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameConsumerConsumerNameDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}/consumer/{consumerName}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"consumerName"+"}", _neturl.PathEscape(parameterToString(r.consumerName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	consumerName    string
	httpmqRequestID *string
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest) Execute() (ApisAPIRestRespOneJetStreamConsumer, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameConsumerConsumerNameGetExecute(r)
}

/*
V1AdminStreamStreamNameConsumerConsumerNameGet Get one consumer of a stream

Query for the details of a consumer on a stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @param consumerName JetStream consumer name
 @return ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerConsumerNameGet(ctx _context.Context, streamName string, consumerName string) ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest {
	return ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest{
		ApiService:   a,
		ctx:          ctx,
		streamName:   streamName,
		consumerName: consumerName,
	}
}

// Execute executes the request
//  @return ApisAPIRestRespOneJetStreamConsumer
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerConsumerNameGetExecute(r ApiV1AdminStreamStreamNameConsumerConsumerNameGetRequest) (ApisAPIRestRespOneJetStreamConsumer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisAPIRestRespOneJetStreamConsumer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameConsumerConsumerNameGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}/consumer/{consumerName}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"consumerName"+"}", _neturl.PathEscape(parameterToString(r.consumerName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameConsumerGetRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	httpmqRequestID *string
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameConsumerGetRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameConsumerGetRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameConsumerGetRequest) Execute() (ApisAPIRestRespAllJetStreamConsumers, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameConsumerGetExecute(r)
}

/*
V1AdminStreamStreamNameConsumerGet Get all consumers of a stream

Query for the details of all consumers of a stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @return ApiV1AdminStreamStreamNameConsumerGetRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerGet(ctx _context.Context, streamName string) ApiV1AdminStreamStreamNameConsumerGetRequest {
	return ApiV1AdminStreamStreamNameConsumerGetRequest{
		ApiService: a,
		ctx:        ctx,
		streamName: streamName,
	}
}

// Execute executes the request
//  @return ApisAPIRestRespAllJetStreamConsumers
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerGetExecute(r ApiV1AdminStreamStreamNameConsumerGetRequest) (ApisAPIRestRespAllJetStreamConsumers, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisAPIRestRespAllJetStreamConsumers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameConsumerGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}/consumer"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameConsumerPostRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	consumerParam   *ManagementJetStreamConsumerParam
	httpmqRequestID *string
}

// Consumer parameters
func (r ApiV1AdminStreamStreamNameConsumerPostRequest) ConsumerParam(consumerParam ManagementJetStreamConsumerParam) ApiV1AdminStreamStreamNameConsumerPostRequest {
	r.consumerParam = &consumerParam
	return r
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameConsumerPostRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameConsumerPostRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameConsumerPostRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameConsumerPostExecute(r)
}

/*
V1AdminStreamStreamNameConsumerPost Create a consumer on a stream

Create a new consumer on a stream. The stream must already be defined.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @return ApiV1AdminStreamStreamNameConsumerPostRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerPost(ctx _context.Context, streamName string) ApiV1AdminStreamStreamNameConsumerPostRequest {
	return ApiV1AdminStreamStreamNameConsumerPostRequest{
		ApiService: a,
		ctx:        ctx,
		streamName: streamName,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminStreamStreamNameConsumerPostExecute(r ApiV1AdminStreamStreamNameConsumerPostRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameConsumerPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}/consumer"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.consumerParam == nil {
		return localVarReturnValue, nil, reportError("consumerParam is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	// body params
	localVarPostBody = r.consumerParam
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameDeleteRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	httpmqRequestID *string
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameDeleteRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameDeleteRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameDeleteRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameDeleteExecute(r)
}

/*
V1AdminStreamStreamNameDelete Delete a stream

Delete a stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @return ApiV1AdminStreamStreamNameDeleteRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameDelete(ctx _context.Context, streamName string) ApiV1AdminStreamStreamNameDeleteRequest {
	return ApiV1AdminStreamStreamNameDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		streamName: streamName,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminStreamStreamNameDeleteExecute(r ApiV1AdminStreamStreamNameDeleteRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameGetRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	httpmqRequestID *string
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameGetRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameGetRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameGetRequest) Execute() (ApisAPIRestRespOneJetStream, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameGetExecute(r)
}

/*
V1AdminStreamStreamNameGet Query for info on one stream

Query for the details of one stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @return ApiV1AdminStreamStreamNameGetRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameGet(ctx _context.Context, streamName string) ApiV1AdminStreamStreamNameGetRequest {
	return ApiV1AdminStreamStreamNameGetRequest{
		ApiService: a,
		ctx:        ctx,
		streamName: streamName,
	}
}

// Execute executes the request
//  @return ApisAPIRestRespOneJetStream
func (a *ManagementApiService) V1AdminStreamStreamNameGetExecute(r ApiV1AdminStreamStreamNameGetRequest) (ApisAPIRestRespOneJetStream, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisAPIRestRespOneJetStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameLimitPutRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	limits          *ManagementJSStreamLimits
	httpmqRequestID *string
}

// New stream limits
func (r ApiV1AdminStreamStreamNameLimitPutRequest) Limits(limits ManagementJSStreamLimits) ApiV1AdminStreamStreamNameLimitPutRequest {
	r.limits = &limits
	return r
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameLimitPutRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameLimitPutRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameLimitPutRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameLimitPutExecute(r)
}

/*
V1AdminStreamStreamNameLimitPut Change limits a stream

Change the data retention limits of a stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @return ApiV1AdminStreamStreamNameLimitPutRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameLimitPut(ctx _context.Context, streamName string) ApiV1AdminStreamStreamNameLimitPutRequest {
	return ApiV1AdminStreamStreamNameLimitPutRequest{
		ApiService: a,
		ctx:        ctx,
		streamName: streamName,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminStreamStreamNameLimitPutExecute(r ApiV1AdminStreamStreamNameLimitPutRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameLimitPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}/limit"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.limits == nil {
		return localVarReturnValue, nil, reportError("limits is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	// body params
	localVarPostBody = r.limits
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AdminStreamStreamNameSubjectPutRequest struct {
	ctx             _context.Context
	ApiService      *ManagementApiService
	streamName      string
	subjects        *ApisAPIRestReqStreamSubjects
	httpmqRequestID *string
}

// List of new subjects
func (r ApiV1AdminStreamStreamNameSubjectPutRequest) Subjects(subjects ApisAPIRestReqStreamSubjects) ApiV1AdminStreamStreamNameSubjectPutRequest {
	r.subjects = &subjects
	return r
}

// User provided request ID to match against logs
func (r ApiV1AdminStreamStreamNameSubjectPutRequest) HttpmqRequestID(httpmqRequestID string) ApiV1AdminStreamStreamNameSubjectPutRequest {
	r.httpmqRequestID = &httpmqRequestID
	return r
}

func (r ApiV1AdminStreamStreamNameSubjectPutRequest) Execute() (ApisStandardResponse, *_nethttp.Response, error) {
	return r.ApiService.V1AdminStreamStreamNameSubjectPutExecute(r)
}

/*
V1AdminStreamStreamNameSubjectPut Change subjects of a stream

Change the list of subjects of interest for a stream

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamName JetStream stream name
 @return ApiV1AdminStreamStreamNameSubjectPutRequest
*/
func (a *ManagementApiService) V1AdminStreamStreamNameSubjectPut(ctx _context.Context, streamName string) ApiV1AdminStreamStreamNameSubjectPutRequest {
	return ApiV1AdminStreamStreamNameSubjectPutRequest{
		ApiService: a,
		ctx:        ctx,
		streamName: streamName,
	}
}

// Execute executes the request
//  @return ApisStandardResponse
func (a *ManagementApiService) V1AdminStreamStreamNameSubjectPutExecute(r ApiV1AdminStreamStreamNameSubjectPutRequest) (ApisStandardResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod  = _nethttp.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue ApisStandardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.V1AdminStreamStreamNameSubjectPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/admin/stream/{streamName}/subject"
	localVarPath = strings.Replace(localVarPath, "{"+"streamName"+"}", _neturl.PathEscape(parameterToString(r.streamName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subjects == nil {
		return localVarReturnValue, nil, reportError("subjects is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.httpmqRequestID != nil {
		localVarHeaderParams["Httpmq-Request-ID"] = parameterToString(*r.httpmqRequestID, "")
	}
	// body params
	localVarPostBody = r.subjects
	req, err := a.client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApisStandardResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
